var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// src/index.ts
var import_generator_helper = require("@prisma/generator-helper");

// src/generate.ts
var import_assert6 = require("assert");
var import_await_event_emitter = __toESM(require("await-event-emitter"));
var import_lodash10 = require("lodash");
var import_ts_morph9 = require("ts-morph");

// src/helpers/pascal-case.ts
var import_lodash = require("lodash");
function pascalCase(string) {
  return (0, import_lodash.startCase)((0, import_lodash.camelCase)(string)).replace(/ /g, "");
}
__name(pascalCase, "pascalCase");

// src/handlers/args-type.ts
function argsType(field, args) {
  if ([
    "queryRaw",
    "executeRaw"
  ].includes(field.name)) {
    return;
  }
  const { eventEmitter, typeNames, getModelName: getModelName2 } = args;
  let className = pascalCase(`${field.name}Args`);
  const modelName = getModelName2(className) || "";
  switch (className) {
    case `Aggregate${modelName}Args`:
      className = `${modelName}AggregateArgs`;
      break;
    case `GroupBy${modelName}Args`:
      className = `${modelName}GroupByArgs`;
      break;
  }
  const inputType1 = {
    constraints: {
      maxNumFields: null,
      minNumFields: null
    },
    name: className,
    fields: [
      ...field.args
    ]
  };
  if (!field.args.some((x) => x.name === "_count") && [
    `${modelName}AggregateArgs`,
    `${modelName}GroupByArgs`
  ].includes(className)) {
    const names = [
      "Count",
      "Avg",
      "Sum",
      "Min",
      "Max"
    ];
    if (`${modelName}GroupByArgs` === inputType1.name) {
      const byField = inputType1.fields.find((f) => f.name === "by");
      if (byField == null ? void 0 : byField.inputTypes) {
        byField.inputTypes = byField.inputTypes.filter((inputType2) => inputType2.isList);
      }
    }
    for (const name of names) {
      if (!typeNames.has(`${modelName}${name}AggregateInput`)) {
        continue;
      }
      inputType1.fields.push({
        name: `_${name.toLowerCase()}`,
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            location: "inputObjectTypes",
            type: `${modelName}${name}AggregateInput`,
            isList: false
          }
        ]
      });
    }
  }
  eventEmitter.emitSync("InputType", {
    ...args,
    inputType: inputType1,
    fileType: "args",
    classDecoratorName: "ArgsType"
  });
}
__name(argsType, "argsType");

// src/handlers/combine-scalar-filters.ts
function combineScalarFilters(eventEmitter) {
  eventEmitter.on("BeforeInputType", beforeInputType);
  eventEmitter.on("BeforeGenerateField", beforeGenerateField);
}
__name(combineScalarFilters, "combineScalarFilters");
function beforeInputType(args) {
  const { inputType: inputType2 } = args;
  if (isContainBogus(inputType2.name) && isScalarFilter(inputType2)) {
    inputType2.name = replaceBogus(String(inputType2.name));
  }
}
__name(beforeInputType, "beforeInputType");
function beforeGenerateField(field) {
  for (const fieldInput of field.inputTypes) {
    if (fieldInput.location !== "inputObjectTypes") {
      continue;
    }
    const fieldInputType = String(fieldInput.type);
    if (isContainBogus(fieldInputType)) {
      fieldInput.type = replaceBogus(fieldInputType);
    }
  }
}
__name(beforeGenerateField, "beforeGenerateField");
function replaceBogus(name) {
  return name.replace(/(Nullable|Nested)/g, "");
}
__name(replaceBogus, "replaceBogus");
function isContainBogus(name) {
  return name.startsWith("Nested") || name.includes("Nullable") && name.endsWith("Filter") || name.endsWith("NullableFilter");
}
__name(isContainBogus, "isContainBogus");
function isScalarFilter(inputType2) {
  if (!inputType2.name.endsWith("Filter")) {
    return false;
  }
  let result = false;
  const equals = inputType2.fields.find((f) => f.name === "equals");
  if (equals) {
    result = equals.inputTypes.every((x) => {
      return [
        "enumTypes",
        "scalar"
      ].includes(x.location);
    });
  }
  return result;
}
__name(isScalarFilter, "isScalarFilter");

// src/handlers/create-aggregate-input.ts
function createAggregateInput(args) {
  const { eventEmitter, outputType: outputType2 } = args;
  const className = `${outputType2.name}Input`;
  const inputType2 = {
    constraints: {
      maxNumFields: null,
      minNumFields: null
    },
    name: className,
    fields: outputType2.fields.map((x) => {
      var _a;
      return {
        name: x.name,
        isNullable: (_a = x.isNullable) != null ? _a : true,
        isRequired: false,
        inputTypes: [
          {
            isList: false,
            type: "true",
            location: "scalar"
          }
        ]
      };
    })
  };
  eventEmitter.emitSync("InputType", {
    ...args,
    inputType: inputType2,
    fileType: "input",
    classDecoratorName: "InputType"
  });
}
__name(createAggregateInput, "createAggregateInput");

// src/handlers/emit-single.ts
function emitSingle(emitter) {
  emitter.on("ClassProperty", classProperty);
}
__name(emitSingle, "emitSingle");
function classProperty(property, eventArguments) {
  const { location, isList, propertyType } = eventArguments;
  if ([
    "inputObjectTypes",
    "outputObjectTypes"
  ].includes(location) && !isList) {
    const types = propertyType.filter((t) => t !== "null");
    property.type = types.map((t) => `InstanceType<typeof ${t}>`).join(" | ");
    if (types.length !== propertyType.length) {
      property.type += " | null";
    }
  }
}
__name(classProperty, "classProperty");

// src/handlers/generate-files.ts
var import_assert = require("assert");
var import_ts_morph2 = require("ts-morph");

// src/helpers/import-declaration-map.ts
var import_ts_morph = require("ts-morph");
var ImportDeclarationMap = class extends Map {
  add(name, value) {
    if (!this.has(name)) {
      const structure = typeof value === "string" ? {
        moduleSpecifier: value,
        namedImports: [
          {
            name
          }
        ]
      } : value;
      this.set(name, structure);
    }
  }
  create(args) {
    const { from, defaultImport, namespaceImport, namedImport } = args;
    let name = args.name;
    const value = {
      moduleSpecifier: from,
      namedImports: [],
      defaultImport: void 0,
      namespaceImport: void 0
    };
    if (namedImport === true && namespaceImport) {
      value.namedImports = [
        {
          name: namespaceImport
        }
      ];
      name = namespaceImport;
    } else if (defaultImport) {
      value.defaultImport = defaultImport === true ? name : defaultImport;
      name = value.defaultImport;
    } else if (namespaceImport) {
      value.namespaceImport = namespaceImport;
      name = namespaceImport;
    } else {
      value.namedImports = [
        {
          name
        }
      ];
    }
    this.add(name, value);
  }
  *toStatements() {
    const iterator = this.values();
    let result = iterator.next();
    while (result.value) {
      yield {
        ...result.value,
        kind: import_ts_morph.StructureKind.ImportDeclaration
      };
      result = iterator.next();
    }
  }
};
__name(ImportDeclarationMap, "ImportDeclarationMap");

// src/handlers/generate-files.ts
async function generateFiles(args) {
  const { project, config, output, eventEmitter } = args;
  if (config.emitSingle) {
    const rootDirectory = project.getDirectory(output) || project.createDirectory(output);
    const sourceFile = rootDirectory.getSourceFile("index.ts") || rootDirectory.createSourceFile("index.ts", void 0, {
      overwrite: true
    });
    const statements1 = project.getSourceFiles().flatMap((s) => {
      var _a, _b;
      if (s === sourceFile) {
        return [];
      }
      const classDeclaration = s.getClass(() => true);
      const statements = s.getStructure().statements;
      if (Array.isArray(statements)) {
        for (const statement of statements) {
          if (!(typeof statement === "object" && statement.kind === import_ts_morph2.StructureKind.Class)) {
            continue;
          }
          for (const property of statement.properties || []) {
            for (const decorator of property.decorators || []) {
              const fullName = (_b = (_a = classDeclaration == null ? void 0 : classDeclaration.getProperty(property.name)) == null ? void 0 : _a.getDecorator(decorator.name)) == null ? void 0 : _b.getFullName();
              (0, import_assert.ok)(fullName, `Cannot get full name of decorator of class ${statement.name}`);
              decorator.name = fullName;
            }
          }
        }
      }
      project.removeSourceFile(s);
      return statements;
    });
    const imports = new ImportDeclarationMap();
    const enums = [];
    const classes = [];
    for (const statement1 of statements1) {
      if (typeof statement1 === "string") {
        if (statement1.startsWith("registerEnumType")) {
          enums.push(statement1);
        }
        continue;
      }
      switch (statement1.kind) {
        case import_ts_morph2.StructureKind.ImportDeclaration:
          if (statement1.moduleSpecifier.startsWith("./") || statement1.moduleSpecifier.startsWith("..")) {
            continue;
          }
          for (const namedImport of statement1.namedImports) {
            const name = namedImport.alias || namedImport.name;
            imports.add(name, statement1.moduleSpecifier);
          }
          if (statement1.defaultImport) {
            imports.create({
              from: statement1.moduleSpecifier,
              name: statement1.defaultImport,
              defaultImport: statement1.defaultImport
            });
          }
          if (statement1.namespaceImport) {
            imports.create({
              from: statement1.moduleSpecifier,
              name: statement1.namespaceImport,
              namespaceImport: statement1.namespaceImport
            });
          }
          break;
        case import_ts_morph2.StructureKind.Enum:
          enums.unshift(statement1);
          break;
        case import_ts_morph2.StructureKind.Class:
          classes.push(statement1);
          break;
      }
    }
    sourceFile.set({
      kind: import_ts_morph2.StructureKind.SourceFile,
      statements: [
        ...imports.toStatements(),
        ...enums,
        ...classes
      ]
    });
  }
  if (config.emitCompiled) {
    project.compilerOptions.set({
      declaration: true,
      declarationDir: output,
      rootDir: output,
      outDir: output,
      emitDecoratorMetadata: false,
      skipLibCheck: true
    });
    const emitResult = await project.emit();
    const errors = emitResult.getDiagnostics().map((d) => String(d.getMessageText()));
    if (errors.length > 0) {
      eventEmitter.emitSync("Warning", errors);
    }
  } else {
    await project.save();
  }
}
__name(generateFiles, "generateFiles");

// src/handlers/input-type.ts
var import_assert2 = require("assert");
var import_json5 = __toESM(require("json5"));
var import_lodash3 = require("lodash");
var import_pupa = __toESM(require("pupa"));
var import_ts_morph4 = require("ts-morph");

// src/helpers/file-type-by-location.ts
function fileTypeByLocation(fieldLocation) {
  switch (fieldLocation) {
    case "inputObjectTypes":
      return "input";
    case "outputObjectTypes":
      return "output";
    case "enumTypes":
      return "enum";
  }
  return "object";
}
__name(fileTypeByLocation, "fileTypeByLocation");

// src/helpers/relative-path.ts
var import_get_relative_path = __toESM(require("get-relative-path"));
function relativePath(from, to) {
  if (!from.startsWith("/")) {
    from = `/${from}`;
  }
  if (!to.startsWith("/")) {
    to = `/${to}`;
  }
  let result = (0, import_get_relative_path.default)(from, to);
  if (!result.startsWith(".")) {
    result = `./${result}`;
  }
  if (result.endsWith(".ts")) {
    result = result.slice(0, -3);
  }
  return result;
}
__name(relativePath, "relativePath");

// src/helpers/get-graphql-import.ts
function getGraphqlImport(args) {
  const { config, fileType, location, typeName, isId, noTypeId, sourceFile, getSourceFile } = args;
  if (location === "scalar") {
    if (isId && !noTypeId) {
      return {
        name: "ID",
        specifier: "@nestjs/graphql"
      };
    }
    const graphqlType = config.graphqlScalars[typeName];
    if (graphqlType) {
      return {
        name: graphqlType.name,
        specifier: graphqlType.specifier
      };
    }
    switch (typeName) {
      case "Float":
      case "Int":
        return {
          name: typeName,
          specifier: "@nestjs/graphql"
        };
      case "DateTime":
        return {
          name: "Date",
          specifier: void 0
        };
      case "true":
      case "Boolean":
        return {
          name: "Boolean",
          specifier: void 0
        };
      case "Decimal":
        return {
          name: "GraphQLDecimal",
          specifier: "prisma-graphql-type-decimal"
        };
      case "Json":
        return {
          name: "GraphQLJSON",
          specifier: "graphql-type-json"
        };
    }
    return {
      name: "String",
      specifier: void 0
    };
  }
  let sourceFileType = fileTypeByLocation(location);
  if (sourceFileType === "output" && fileType === "model") {
    sourceFileType = "model";
  }
  const specifier = relativePath(sourceFile.getFilePath(), getSourceFile({
    type: sourceFileType,
    name: typeName
  }).getFilePath());
  return {
    name: typeName,
    specifier
  };
}
__name(getGraphqlImport, "getGraphqlImport");

// src/helpers/get-graphql-input-type.ts
var import_lodash2 = require("lodash");
var import_outmatch = __toESM(require("outmatch"));
function getGraphqlInputType(inputTypes, pattern) {
  let result;
  inputTypes = inputTypes.filter((t) => ![
    "null",
    "Null"
  ].includes(String(t.type)));
  inputTypes = (0, import_lodash2.uniqWith)(inputTypes, import_lodash2.isEqual);
  if (inputTypes.length === 1) {
    return inputTypes[0];
  }
  const countTypes = (0, import_lodash2.countBy)(inputTypes, (x) => x.location);
  const isOneType = Object.keys(countTypes).length === 1;
  if (isOneType) {
    result = inputTypes.find((x) => x.isList);
    if (result) {
      return result;
    }
  }
  if (pattern) {
    if (pattern.startsWith("matcher:") || pattern.startsWith("match:")) {
      const { 1: patternValue } = pattern.split(":", 2);
      const isMatch = (0, import_outmatch.default)(patternValue, {
        separator: false
      });
      result = inputTypes.find((x) => isMatch(String(x.type)));
      if (result) {
        return result;
      }
    }
    result = inputTypes.find((x) => String(x.type).includes(pattern));
    if (result) {
      return result;
    }
  }
  result = inputTypes.find((x) => x.location === "inputObjectTypes");
  if (result) {
    return result;
  }
  if (countTypes.enumTypes && countTypes.scalar && inputTypes.some((x) => x.type === "Json" && x.location === "scalar")) {
    result = inputTypes.find((x) => x.type === "Json" && x.location === "scalar");
    if (result) {
      return result;
    }
  }
  throw new TypeError(`Cannot get matching input type from ${inputTypes.map((x) => x.type).join(", ") || "zero length inputTypes"}`);
}
__name(getGraphqlInputType, "getGraphqlInputType");

// src/helpers/get-property-type.ts
function getPropertyType(args) {
  const { type, location } = args;
  switch (type) {
    case "Float":
    case "Int":
      return [
        "number"
      ];
    case "String":
      return [
        "string"
      ];
    case "Boolean":
      return [
        "boolean"
      ];
    case "DateTime":
      return [
        "Date",
        "string"
      ];
    case "Decimal":
      return [
        "Decimal"
      ];
    case "Json":
      return [
        "any"
      ];
    case "Null":
      return [
        "null"
      ];
    case "Bytes":
      return [
        "Buffer"
      ];
    case "BigInt":
      return [
        "bigint",
        "number"
      ];
  }
  if ([
    "inputObjectTypes",
    "outputObjectTypes"
  ].includes(location)) {
    return [
      type
    ];
  }
  if (location === "enumTypes") {
    return [
      `keyof typeof ${type}`
    ];
  }
  if (location === "scalar") {
    return [
      type
    ];
  }
  return [
    "unknown"
  ];
}
__name(getPropertyType, "getPropertyType");

// src/helpers/property-structure.ts
var import_ts_morph3 = require("ts-morph");
function propertyStructure(args) {
  const { isNullable, propertyType, name, isList, hasQuestionToken, hasExclamationToken } = args;
  const type1 = propertyType.map((type) => isList ? `Array<${type}>` : type).join(" | ");
  return {
    kind: import_ts_morph3.StructureKind.Property,
    name,
    type: type1,
    hasQuestionToken: hasQuestionToken != null ? hasQuestionToken : isNullable,
    hasExclamationToken: hasExclamationToken != null ? hasExclamationToken : !isNullable,
    decorators: [],
    leadingTrivia: "\n"
  };
}
__name(propertyStructure, "propertyStructure");

// src/handlers/input-type.ts
function inputType(args) {
  var _a, _b, _c, _d;
  const { inputType: inputType1, fileType, getSourceFile, config, eventEmitter, classDecoratorName, fieldSettings, getModelName: getModelName2, models, removeTypes, typeNames } = args;
  typeNames.add(inputType1.name);
  const importDeclarations = new ImportDeclarationMap();
  const sourceFile = getSourceFile({
    name: inputType1.name,
    type: fileType
  });
  const classStructure = {
    kind: import_ts_morph4.StructureKind.Class,
    isExported: true,
    name: inputType1.name,
    decorators: [
      {
        name: classDecoratorName,
        arguments: []
      }
    ],
    properties: []
  };
  const modelName = getModelName2(inputType1.name) || "";
  const model = models.get(modelName);
  const modelFieldSettings = model && fieldSettings.get(model.name);
  const moduleSpecifier = "@nestjs/graphql";
  importDeclarations.set("Field", {
    namedImports: [
      {
        name: "Field"
      }
    ],
    moduleSpecifier
  }).set(classDecoratorName, {
    namedImports: [
      {
        name: classDecoratorName
      }
    ],
    moduleSpecifier
  });
  const useInputType = config.useInputType.find((x) => inputType1.name.includes(x.typeName));
  for (const field of inputType1.fields) {
    field.inputTypes = field.inputTypes.filter((t) => !removeTypes.has(String(t.type)));
    eventEmitter.emitSync("BeforeGenerateField", field, args);
    const { inputTypes, isRequired, name } = field;
    if (inputTypes.length === 0) {
      continue;
    }
    const usePattern = (useInputType == null ? void 0 : useInputType.ALL) || (useInputType == null ? void 0 : useInputType[name]);
    const graphqlInputType = getGraphqlInputType(inputTypes, usePattern);
    const { isList, location, type } = graphqlInputType;
    const typeName = String(type);
    const settings = modelFieldSettings == null ? void 0 : modelFieldSettings.get(name);
    const propertySettings = settings == null ? void 0 : settings.getPropertyType({
      name: inputType1.name,
      input: true
    });
    const isCustomsApplicable = typeName === ((_a = model == null ? void 0 : model.fields.find((f) => f.name === name)) == null ? void 0 : _a.type);
    const propertyType = (0, import_lodash3.castArray)((propertySettings == null ? void 0 : propertySettings.name) || getPropertyType({
      location,
      type: typeName
    }));
    const property = propertyStructure({
      name,
      isNullable: !isRequired,
      propertyType,
      isList
    });
    classStructure.properties.push(property);
    if (propertySettings) {
      importDeclarations.create({
        ...propertySettings
      });
    } else if (propertyType.includes("Decimal")) {
      importDeclarations.add("Decimal", "@prisma/client/runtime");
    }
    let graphqlType;
    const shouldHideField = (settings == null ? void 0 : settings.shouldHideField({
      name: inputType1.name,
      input: true
    })) || config.decorate.some((d) => d.name === "HideField" && d.from === "@nestjs/graphql" && d.isMatchField(name) && d.isMatchType(inputType1.name));
    const fieldType = settings == null ? void 0 : settings.getFieldType({
      name: inputType1.name,
      input: true
    });
    if (fieldType && isCustomsApplicable && !shouldHideField) {
      graphqlType = fieldType.name;
      importDeclarations.create({
        ...fieldType
      });
    } else {
      const graphqlImport = getGraphqlImport({
        config,
        sourceFile,
        location,
        typeName,
        getSourceFile
      });
      graphqlType = graphqlImport.name;
      let referenceName = propertyType[0];
      if (location === "enumTypes") {
        referenceName = (0, import_lodash3.last)(referenceName.split(" "));
      }
      if (graphqlImport.specifier && !importDeclarations.has(graphqlImport.name) && graphqlImport.name !== inputType1.name) {
        importDeclarations.set(graphqlImport.name, {
          namedImports: [
            {
              name: graphqlImport.name
            }
          ],
          moduleSpecifier: graphqlImport.specifier
        });
      }
    }
    (0, import_assert2.ok)(property.decorators, "property.decorators is undefined");
    if (shouldHideField) {
      importDeclarations.add("HideField", "@nestjs/graphql");
      property.decorators.push({
        name: "HideField",
        arguments: []
      });
    } else {
      property.decorators.push({
        name: "Field",
        arguments: [
          isList ? `() => [${graphqlType}]` : `() => ${graphqlType}`,
          import_json5.default.stringify({
            nullable: !isRequired
          })
        ]
      });
      if (isCustomsApplicable) {
        for (const options of settings || []) {
          if ((_c = options.kind === "Decorator" && options.input && ((_b = options.match) == null ? void 0 : _b.call(options, name))) != null ? _c : true) {
            property.decorators.push({
              name: options.name,
              arguments: options.arguments
            });
            (0, import_assert2.ok)(options.from, "Missed 'from' part in configuration or field setting");
            importDeclarations.create(options);
          }
        }
      }
      for (const decorate of config.decorate) {
        if (decorate.isMatchField(name) && decorate.isMatchType(inputType1.name)) {
          property.decorators.push({
            name: decorate.name,
            arguments: (_d = decorate.arguments) == null ? void 0 : _d.map((x) => (0, import_pupa.default)(x, {
              propertyType
            }))
          });
          importDeclarations.create(decorate);
        }
      }
    }
    eventEmitter.emitSync("ClassProperty", property, {
      location,
      isList,
      propertyType
    });
  }
  sourceFile.set({
    statements: [
      ...importDeclarations.toStatements(),
      classStructure
    ]
  });
}
__name(inputType, "inputType");

// src/helpers/object-settings.ts
var import_json52 = __toESM(require("json5"));
var import_lodash4 = require("lodash");
var import_outmatch2 = __toESM(require("outmatch"));
var ObjectSettings = class extends Array {
  shouldHideField({ name, input = false, output = false }) {
    var _a;
    const hideField = this.find((s) => s.name === "HideField");
    return Boolean((hideField == null ? void 0 : hideField.input) && input || (hideField == null ? void 0 : hideField.output) && output || ((_a = hideField == null ? void 0 : hideField.match) == null ? void 0 : _a.call(hideField, name)));
  }
  getFieldType({ name, input, output }) {
    const fieldType = this.find((s) => s.kind === "FieldType");
    if (!fieldType) {
      return void 0;
    }
    if (fieldType.match) {
      return fieldType.match(name) ? fieldType : void 0;
    }
    if (input && !fieldType.input) {
      return void 0;
    }
    if (output && !fieldType.output) {
      return void 0;
    }
    return fieldType;
  }
  getPropertyType({ name, input, output }) {
    const propertyType = this.find((s) => s.kind === "PropertyType");
    if (!propertyType) {
      return void 0;
    }
    if (propertyType.match) {
      return propertyType.match(name) ? propertyType : void 0;
    }
    if (input && !propertyType.input) {
      return void 0;
    }
    if (output && !propertyType.output) {
      return void 0;
    }
    return propertyType;
  }
  getObjectTypeArguments(options) {
    const objectTypeOptions = (0, import_lodash4.merge)({}, options);
    const resultArguments = [
      objectTypeOptions
    ];
    const objectType = this.find((s) => s.kind === "ObjectType");
    if (objectType && (0, import_lodash4.isObject)(objectType.arguments)) {
      const name = objectType.arguments.name;
      (0, import_lodash4.merge)(objectTypeOptions, (0, import_lodash4.omit)(objectType.arguments, "name"));
      if (name) {
        resultArguments.unshift(name);
      }
    }
    return resultArguments.map((x) => import_json52.default.stringify(x));
  }
};
__name(ObjectSettings, "ObjectSettings");
function createObjectSettings(args) {
  var _a, _b, _c, _d, _e;
  const { config, text } = args;
  const result = new ObjectSettings();
  const textLines = text.split("\n");
  const documentationLines = [];
  for (const line of textLines) {
    const match = /^@(?<name>\w+(\.(\w+))?)\((?<args>.*)\)/.exec(line);
    const name = (_a = match == null ? void 0 : match.groups) == null ? void 0 : _a.name;
    if (!match || !name) {
      documentationLines.push(line);
      continue;
    }
    const element = {
      kind: "Decorator",
      name: "",
      arguments: [],
      input: false,
      output: false,
      model: false,
      from: ""
    };
    if (name === "TypeGraphQL.omit" || name === "HideField") {
      Object.assign(element, hideFieldDecorator(match));
    } else if ([
      "FieldType",
      "PropertyType"
    ].includes(name) && ((_b = match.groups) == null ? void 0 : _b.args)) {
      const options = customType(match.groups.args);
      (0, import_lodash4.merge)(element, options.namespace && config.fields[options.namespace], options, {
        kind: name
      });
    } else if (name === "ObjectType" && ((_c = match.groups) == null ? void 0 : _c.args)) {
      element.kind = "ObjectType";
      const options = customType(match.groups.args);
      if (typeof options[0] === "string" && options[0]) {
        options.name = options[0];
      }
      if ((0, import_lodash4.isObject)(options[1])) {
        (0, import_lodash4.merge)(options, options[1]);
      }
      element.arguments = {
        name: options.name,
        isAbstract: options.isAbstract
      };
    } else if (name === "Directive" && ((_d = match.groups) == null ? void 0 : _d.args)) {
      const options = customType(match.groups.args);
      (0, import_lodash4.merge)(element, {
        model: true,
        from: "@nestjs/graphql"
      }, options, {
        name,
        namespace: false,
        kind: "Decorator",
        arguments: Array.isArray(options.arguments) ? options.arguments.map((s) => import_json52.default.stringify(s)) : options.arguments
      });
    } else {
      const namespace = getNamespace(name);
      element.namespaceImport = namespace;
      const options = {
        name,
        arguments: (((_e = match.groups) == null ? void 0 : _e.args) || "").split(",").map((s) => (0, import_lodash4.trim)(s)).filter(Boolean)
      };
      (0, import_lodash4.merge)(element, namespace && config.fields[namespace], options);
    }
    result.push(element);
  }
  return {
    settings: result,
    documentation: documentationLines.filter(Boolean).join("\\n") || void 0
  };
}
__name(createObjectSettings, "createObjectSettings");
function customType(args) {
  var _a;
  const result = {};
  let options = parseArgs(args);
  if (typeof options === "string") {
    options = {
      name: options
    };
  }
  Object.assign(result, options);
  const namespace = getNamespace(options.name);
  result.namespace = namespace;
  if ((_a = options.name) == null ? void 0 : _a.includes(".")) {
    result.namespaceImport = namespace;
  }
  if (typeof options.match === "string" || Array.isArray(options.match)) {
    result.match = (0, import_outmatch2.default)(options.match, {
      separator: false
    });
  }
  return result;
}
__name(customType, "customType");
function hideFieldDecorator(match) {
  var _a;
  const result = {
    name: "HideField",
    arguments: [],
    from: "@nestjs/graphql",
    defaultImport: void 0,
    namespaceImport: void 0,
    match: void 0
  };
  if (!((_a = match.groups) == null ? void 0 : _a.args)) {
    result.output = true;
    return result;
  }
  if (match.groups.args.includes("{") && match.groups.args.includes("}")) {
    const options = parseArgs(match.groups.args);
    result.output = Boolean(options.output);
    result.input = Boolean(options.input);
    if (typeof options.match === "string" || Array.isArray(options.match)) {
      result.match = (0, import_outmatch2.default)(options.match, {
        separator: false
      });
    }
  } else {
    if (/output:\s*true/.test(match.groups.args)) {
      result.output = true;
    }
    if (/input:\s*true/.test(match.groups.args)) {
      result.input = true;
    }
  }
  return result;
}
__name(hideFieldDecorator, "hideFieldDecorator");
function parseArgs(string) {
  try {
    return import_json52.default.parse(string);
  } catch (e) {
    try {
      return import_json52.default.parse(`[${string}]`);
    } catch (e2) {
      throw new Error(`Failed to parse: ${string}`);
    }
  }
}
__name(parseArgs, "parseArgs");
function getNamespace(name) {
  if (name === void 0) {
    return void 0;
  }
  let result = String(name);
  if (result.includes(".")) {
    [result] = result.split(".");
  }
  return result;
}
__name(getNamespace, "getNamespace");

// src/handlers/model-data.ts
function modelData(model, args) {
  const { config, modelNames, models, modelFields, fieldSettings } = args;
  modelNames.push(model.name);
  models.set(model.name, model);
  const modelFieldsValue = /* @__PURE__ */ new Map();
  modelFields.set(model.name, modelFieldsValue);
  const fieldSettingsValue = /* @__PURE__ */ new Map();
  fieldSettings.set(model.name, fieldSettingsValue);
  for (const field of model.fields) {
    if (field.documentation) {
      const { documentation, settings } = createObjectSettings({
        text: field.documentation,
        config
      });
      field.documentation = documentation;
      fieldSettingsValue.set(field.name, settings);
    }
    modelFieldsValue.set(field.name, field);
  }
}
__name(modelData, "modelData");

// src/handlers/model-output-type.ts
var import_assert3 = require("assert");
var import_json53 = __toESM(require("json5"));
var import_lodash5 = require("lodash");
var import_pupa2 = __toESM(require("pupa"));
var import_ts_morph5 = require("ts-morph");

// src/helpers/get-output-type-name.ts
function getOutputTypeName(name) {
  return name.replace(/(?:OutputType|Output)$/, "");
}
__name(getOutputTypeName, "getOutputTypeName");

// src/handlers/model-output-type.ts
var nestjsGraphql = "@nestjs/graphql";
function modelOutputType(outputType2, args) {
  var _a, _b, _c, _d, _e, _f;
  const { getSourceFile, models, config, modelFields, fieldSettings, eventEmitter } = args;
  const model = models.get(outputType2.name);
  (0, import_assert3.ok)(model, `Cannot find model by name ${outputType2.name}`);
  const sourceFile = getSourceFile({
    name: outputType2.name,
    type: "model"
  });
  const sourceFileStructure = sourceFile.getStructure();
  const exportDeclaration = getExportDeclaration(model.name, sourceFileStructure.statements);
  const importDeclarations = new ImportDeclarationMap();
  const classStructure = {
    kind: import_ts_morph5.StructureKind.Class,
    isExported: true,
    name: outputType2.name,
    decorators: [
      {
        name: "ObjectType",
        arguments: []
      }
    ],
    properties: []
  };
  sourceFileStructure.statements.push(classStructure);
  (0, import_assert3.ok)(classStructure.decorators, "classStructure.decorators is undefined");
  const decorator = classStructure.decorators.find((d) => d.name === "ObjectType");
  (0, import_assert3.ok)(decorator, "ObjectType decorator not found");
  let modelSettings;
  if (model.documentation) {
    const objectTypeOptions = {};
    const { documentation, settings } = createObjectSettings({
      text: model.documentation,
      config
    });
    if (documentation) {
      if (!classStructure.leadingTrivia) {
        classStructure.leadingTrivia = `/** ${documentation} */
`;
      }
      objectTypeOptions.description = documentation;
    }
    decorator.arguments = settings.getObjectTypeArguments(objectTypeOptions);
    modelSettings = settings;
  }
  importDeclarations.add("Field", nestjsGraphql);
  importDeclarations.add("ObjectType", nestjsGraphql);
  for (const field of outputType2.fields) {
    let fileType = "model";
    const { location, isList, type, namespace } = field.outputType;
    let outputTypeName = String(type);
    if (namespace !== "model") {
      fileType = "output";
      outputTypeName = getOutputTypeName(outputTypeName);
    }
    const modelField = (_a = modelFields.get(model.name)) == null ? void 0 : _a.get(field.name);
    const settings = (_b = fieldSettings.get(model.name)) == null ? void 0 : _b.get(field.name);
    const fieldType = settings == null ? void 0 : settings.getFieldType({
      name: outputType2.name,
      output: true
    });
    const propertySettings = settings == null ? void 0 : settings.getPropertyType({
      name: outputType2.name,
      output: true
    });
    const propertyType = (0, import_lodash5.castArray)((propertySettings == null ? void 0 : propertySettings.name) || getPropertyType({
      location,
      type: outputTypeName
    }));
    propertyType.splice(1, propertyType.length);
    if (field.isNullable && !isList) {
      propertyType.push("null");
    }
    let graphqlType;
    if (fieldType) {
      graphqlType = fieldType.name;
      importDeclarations.create({
        ...fieldType
      });
    } else {
      const graphqlImport = getGraphqlImport({
        config,
        sourceFile,
        fileType,
        location,
        isId: modelField == null ? void 0 : modelField.isId,
        noTypeId: config.noTypeId,
        typeName: outputTypeName,
        getSourceFile
      });
      graphqlType = graphqlImport.name;
      if (graphqlImport.name !== outputType2.name && graphqlImport.specifier) {
        importDeclarations.add(graphqlImport.name, graphqlImport.specifier);
      }
    }
    const property = propertyStructure({
      name: field.name,
      isNullable: field.isNullable,
      hasExclamationToken: true,
      hasQuestionToken: location === "outputObjectTypes",
      propertyType,
      isList
    });
    if (typeof property.leadingTrivia === "string" && (modelField == null ? void 0 : modelField.documentation)) {
      property.leadingTrivia += `/** ${modelField.documentation} */
`;
    }
    (_c = classStructure.properties) == null ? void 0 : _c.push(property);
    if (propertySettings) {
      importDeclarations.create({
        ...propertySettings
      });
    } else if (!propertySettings && propertyType.includes("Decimal")) {
      importDeclarations.add("Decimal", "@prisma/client/runtime");
    }
    (0, import_assert3.ok)(property.decorators, "property.decorators is undefined");
    if (settings == null ? void 0 : settings.shouldHideField({
      name: outputType2.name,
      output: true
    })) {
      importDeclarations.add("HideField", nestjsGraphql);
      property.decorators.push({
        name: "HideField",
        arguments: []
      });
    } else {
      property.decorators.push({
        name: "Field",
        arguments: [
          isList ? `() => [${graphqlType}]` : `() => ${graphqlType}`,
          import_json53.default.stringify({
            nullable: Boolean(field.isNullable),
            defaultValue: [
              "number",
              "string",
              "boolean"
            ].includes(typeof (modelField == null ? void 0 : modelField.default)) ? modelField == null ? void 0 : modelField.default : void 0,
            description: modelField == null ? void 0 : modelField.documentation
          })
        ]
      });
      for (const setting of settings || []) {
        if (shouldBeDecorated(setting) && ((_e = (_d = setting.match) == null ? void 0 : _d.call(setting, field.name)) != null ? _e : true)) {
          property.decorators.push({
            name: setting.name,
            arguments: setting.arguments
          });
          (0, import_assert3.ok)(setting.from, "Missed 'from' part in configuration or field setting");
          importDeclarations.create(setting);
        }
      }
      for (const decorate of config.decorate) {
        if (decorate.isMatchField(field.name) && decorate.isMatchType(outputTypeName)) {
          property.decorators.push({
            name: decorate.name,
            arguments: (_f = decorate.arguments) == null ? void 0 : _f.map((x) => (0, import_pupa2.default)(x, {
              propertyType
            }))
          });
          importDeclarations.create(decorate);
        }
      }
    }
    eventEmitter.emitSync("ClassProperty", property, {
      location,
      isList,
      propertyType
    });
  }
  for (const setting of modelSettings || []) {
    if (shouldBeDecorated(setting)) {
      classStructure.decorators.push({
        name: setting.name,
        arguments: setting.arguments
      });
      importDeclarations.create(setting);
    }
  }
  if (exportDeclaration) {
    sourceFile.set({
      statements: [
        exportDeclaration,
        "\n",
        classStructure
      ]
    });
    const classDeclaration = sourceFile.getClassOrThrow(model.name);
    const commentedText = classDeclaration.getText().split("\n").map((x) => `// ${x}`);
    classDeclaration.remove();
    sourceFile.addStatements([
      "\n",
      ...commentedText
    ]);
  } else {
    sourceFile.set({
      statements: [
        ...importDeclarations.toStatements(),
        classStructure
      ]
    });
  }
}
__name(modelOutputType, "modelOutputType");
function shouldBeDecorated(setting) {
  return setting.kind === "Decorator" && (setting.output || setting.model) && !(setting.output && setting.model);
}
__name(shouldBeDecorated, "shouldBeDecorated");
function getExportDeclaration(name, statements) {
  return statements.find((structure) => {
    return structure.kind === import_ts_morph5.StructureKind.ExportDeclaration && structure.namedExports.some((o) => (o.alias || o.name) === name);
  });
}
__name(getExportDeclaration, "getExportDeclaration");

// src/handlers/no-atomic-operations.ts
function noAtomicOperations(eventEmitter) {
  eventEmitter.on("BeforeInputType", beforeInputType2);
  eventEmitter.on("BeforeGenerateFiles", beforeGenerateFiles);
}
__name(noAtomicOperations, "noAtomicOperations");
function beforeInputType2(args) {
  const { inputType: inputType1 } = args;
  for (const field of inputType1.fields) {
    field.inputTypes = field.inputTypes.filter((inputType2) => {
      if (isAtomicOperation(String(inputType2.type))) {
        return false;
      }
      return true;
    });
  }
}
__name(beforeInputType2, "beforeInputType");
function beforeGenerateFiles(args) {
  var _a;
  const { project } = args;
  for (const sourceFile of project.getSourceFiles()) {
    const className = (_a = sourceFile.getClass(() => true)) == null ? void 0 : _a.getName();
    if (className && isAtomicOperation(className)) {
      project.removeSourceFile(sourceFile);
    }
  }
}
__name(beforeGenerateFiles, "beforeGenerateFiles");
function isAtomicOperation(name) {
  return name.endsWith("FieldUpdateOperationsInput");
}
__name(isAtomicOperation, "isAtomicOperation");

// src/handlers/output-type.ts
var import_assert4 = require("assert");
var import_json54 = __toESM(require("json5"));
var import_lodash6 = require("lodash");
var import_ts_morph6 = require("ts-morph");
var nestjsGraphql2 = "@nestjs/graphql";
function outputType(outputType1, args) {
  var _a, _b, _c, _d, _e;
  const { getSourceFile, models, eventEmitter, fieldSettings, getModelName: getModelName2, config } = args;
  const importDeclarations = new ImportDeclarationMap();
  const fileType = "output";
  const modelName = getModelName2(outputType1.name) || "";
  const model = models.get(modelName);
  const isAggregateOutput = model && /(?:Count|Avg|Sum|Min|Max)AggregateOutputType$/.test(outputType1.name) && String(outputType1.name).startsWith(model.name);
  const isCountOutput = (model == null ? void 0 : model.name) && outputType1.name === `${model.name}CountOutputType`;
  outputType1.name = getOutputTypeName(outputType1.name);
  if (isAggregateOutput) {
    eventEmitter.emitSync("AggregateOutput", {
      ...args,
      outputType: outputType1
    });
  }
  const sourceFile = getSourceFile({
    name: outputType1.name,
    type: fileType
  });
  const classStructure = {
    kind: import_ts_morph6.StructureKind.Class,
    isExported: true,
    name: outputType1.name,
    decorators: [
      {
        name: "ObjectType",
        arguments: []
      }
    ],
    properties: []
  };
  importDeclarations.add("Field", nestjsGraphql2);
  importDeclarations.add("ObjectType", nestjsGraphql2);
  for (const field of outputType1.fields) {
    const { location, isList, type } = field.outputType;
    const outputTypeName = getOutputTypeName(String(type));
    const settings = isCountOutput ? void 0 : model && ((_a = fieldSettings.get(model.name)) == null ? void 0 : _a.get(field.name));
    const propertySettings = settings == null ? void 0 : settings.getPropertyType({
      name: outputType1.name,
      output: true
    });
    const isCustomsApplicable = outputTypeName === ((_b = model == null ? void 0 : model.fields.find((f) => f.name === field.name)) == null ? void 0 : _b.type);
    field.outputType.type = outputTypeName;
    const propertyType = (0, import_lodash6.castArray)((propertySettings == null ? void 0 : propertySettings.name) || getPropertyType({
      location,
      type: outputTypeName
    }));
    const property = propertyStructure({
      name: field.name,
      isNullable: field.isNullable,
      hasQuestionToken: isCountOutput ? true : void 0,
      propertyType,
      isList
    });
    (_c = classStructure.properties) == null ? void 0 : _c.push(property);
    if (propertySettings) {
      importDeclarations.create({
        ...propertySettings
      });
    } else if (propertyType.includes("Decimal")) {
      importDeclarations.add("Decimal", "@prisma/client/runtime");
    }
    let graphqlType;
    const shouldHideField = (settings == null ? void 0 : settings.shouldHideField({
      name: outputType1.name,
      output: true
    })) || config.decorate.some((d) => d.name === "HideField" && d.from === "@nestjs/graphql" && d.isMatchField(field.name) && d.isMatchType(outputTypeName));
    const fieldType = settings == null ? void 0 : settings.getFieldType({
      name: outputType1.name,
      output: true
    });
    if (fieldType && isCustomsApplicable && !shouldHideField) {
      graphqlType = fieldType.name;
      importDeclarations.create({
        ...fieldType
      });
    } else {
      const graphqlImport = getGraphqlImport({
        config,
        sourceFile,
        fileType,
        location,
        isId: false,
        typeName: outputTypeName,
        getSourceFile
      });
      graphqlType = graphqlImport.name;
      let referenceName = propertyType[0];
      if (location === "enumTypes") {
        referenceName = (0, import_lodash6.last)(referenceName.split(" "));
      }
      if (graphqlImport.specifier && !importDeclarations.has(graphqlImport.name) && (graphqlImport.name !== outputType1.name && !shouldHideField || shouldHideField && referenceName === graphqlImport.name)) {
        importDeclarations.set(graphqlImport.name, {
          namedImports: [
            {
              name: graphqlImport.name
            }
          ],
          moduleSpecifier: graphqlImport.specifier
        });
      }
    }
    (0, import_assert4.ok)(property.decorators, "property.decorators is undefined");
    if (shouldHideField) {
      importDeclarations.add("HideField", nestjsGraphql2);
      property.decorators.push({
        name: "HideField",
        arguments: []
      });
    } else {
      property.decorators.push({
        name: "Field",
        arguments: [
          isList ? `() => [${graphqlType}]` : `() => ${graphqlType}`,
          import_json54.default.stringify({
            nullable: Boolean(field.isNullable)
          })
        ]
      });
      if (isCustomsApplicable) {
        for (const options of settings || []) {
          if ((_e = options.kind === "Decorator" && options.output && ((_d = options.match) == null ? void 0 : _d.call(options, field.name))) != null ? _e : true) {
            property.decorators.push({
              name: options.name,
              arguments: options.arguments
            });
            (0, import_assert4.ok)(options.from, "Missed 'from' part in configuration or field setting");
            importDeclarations.create(options);
          }
        }
      }
    }
    eventEmitter.emitSync("ClassProperty", property, {
      location,
      isList,
      propertyType
    });
  }
  sourceFile.set({
    statements: [
      ...importDeclarations.toStatements(),
      classStructure
    ]
  });
}
__name(outputType, "outputType");

// src/handlers/purge-output.ts
var import_fs = require("fs");
function purgeOutput(emitter) {
  emitter.on("Begin", begin);
  emitter.on("End", end);
}
__name(purgeOutput, "purgeOutput");
function begin({ project, output }) {
  var _a;
  const sourceFiles = (_a = project.getDirectory(output)) == null ? void 0 : _a.getDescendantSourceFiles();
  if (sourceFiles) {
    for (const sourceFile of sourceFiles) {
      sourceFile.delete();
    }
  }
}
__name(begin, "begin");
async function end({ project, output }) {
  var _a;
  const directories = (_a = project.getDirectory(output)) == null ? void 0 : _a.getDescendantDirectories().filter((directory) => directory.getSourceFiles().length === 0).map((directory) => directory.getPath());
  for (const directory1 of directories || []) {
    try {
      await import_fs.promises.rmdir(directory1);
    } catch (e) {
    }
  }
}
__name(end, "end");

// src/handlers/re-export.ts
var import_ts_morph7 = require("ts-morph");
var ReExport;
(function(ReExport2) {
  ReExport2["None"] = "None";
  ReExport2["Directories"] = "Directories";
  ReExport2["Single"] = "Single";
  ReExport2["All"] = "All";
})(ReExport || (ReExport = {}));
function reExport(emitter) {
  emitter.on("BeforeGenerateFiles", beforeGenerateFiles2);
}
__name(reExport, "reExport");
function beforeGenerateFiles2(args) {
  const { project, output, config } = args;
  const rootDirectory = project.getDirectoryOrThrow(output);
  if ([
    ReExport.Directories,
    ReExport.All
  ].includes(config.reExport)) {
    for (const directory of rootDirectory.getDescendantDirectories()) {
      let indexSourceFile;
      const exportDeclarations = directory.getSourceFiles().filter((sourceFile) => {
        return sourceFile.getBaseName() !== "index.ts";
      }).map((sourcesFile) => getExportDeclaration2(directory, sourcesFile));
      if (exportDeclarations.length > 0) {
        indexSourceFile = directory.createSourceFile("index.ts", {
          statements: exportDeclarations
        }, {
          overwrite: true
        });
      }
      if (indexSourceFile) {
        continue;
      }
      const namespaceExportDeclarations = directory.getDirectories().map((sourceDirectory) => getNamespaceExportDeclaration(directory, sourceDirectory));
      project.createSourceFile(`${directory.getPath()}/index.ts`, {
        statements: namespaceExportDeclarations
      }, {
        overwrite: true
      });
    }
  }
  if (config.reExport === ReExport.Single) {
    const exportDeclarations = project.getSourceFiles().filter((sourceFile) => {
      return sourceFile.getBaseName() !== "index.ts";
    }).map((sourceFile) => getExportDeclaration2(rootDirectory, sourceFile));
    rootDirectory.createSourceFile("index.ts", {
      statements: exportDeclarations
    }, {
      overwrite: true
    });
  }
  if (config.reExport === ReExport.All) {
    const exportDeclarations = [];
    for (const directory of rootDirectory.getDirectories()) {
      const sourceFile = directory.getSourceFileOrThrow("index.ts");
      exportDeclarations.push(getExportDeclaration2(rootDirectory, sourceFile));
    }
    rootDirectory.createSourceFile("index.ts", {
      statements: exportDeclarations
    }, {
      overwrite: true
    });
  }
}
__name(beforeGenerateFiles2, "beforeGenerateFiles");
function getExportDeclaration2(directory, sourceFile) {
  return {
    kind: import_ts_morph7.StructureKind.ExportDeclaration,
    namedExports: sourceFile.getExportSymbols().map((s) => ({
      name: s.getName()
    })),
    moduleSpecifier: directory.getRelativePathAsModuleSpecifierTo(sourceFile)
  };
}
__name(getExportDeclaration2, "getExportDeclaration");
function getNamespaceExportDeclaration(directory, sourceDirectory) {
  return {
    kind: import_ts_morph7.StructureKind.ExportDeclaration,
    moduleSpecifier: directory.getRelativePathAsModuleSpecifierTo(sourceDirectory)
  };
}
__name(getNamespaceExportDeclaration, "getNamespaceExportDeclaration");

// src/handlers/register-enum.ts
var import_ts_morph8 = require("ts-morph");
function registerEnum(enumType, args) {
  const { getSourceFile, enums } = args;
  const dataModelEnum = enums[enumType.name];
  const sourceFile = getSourceFile({
    name: enumType.name,
    type: "enum"
  });
  const importDeclarations = new ImportDeclarationMap();
  importDeclarations.set("registerEnumType", {
    namedImports: [
      {
        name: "registerEnumType"
      }
    ],
    moduleSpecifier: "@nestjs/graphql"
  });
  const enumStructure = {
    kind: import_ts_morph8.StructureKind.Enum,
    isExported: true,
    name: enumType.name,
    members: enumType.values.map((v) => ({
      name: v,
      initializer: JSON.stringify(v)
    }))
  };
  sourceFile.set({
    statements: [
      ...importDeclarations.toStatements(),
      enumStructure,
      "\n",
      `registerEnumType(${enumType.name}, { name: '${enumType.name}', description: ${JSON.stringify(dataModelEnum == null ? void 0 : dataModelEnum.documentation)} })`
    ]
  });
}
__name(registerEnum, "registerEnum");

// src/handlers/require-single-fields-in-whereunique-input.ts
function requireSingleFieldsInWhereUniqueInput(eventEmitter) {
  eventEmitter.on("BeforeInputType", beforeInputType3);
}
__name(requireSingleFieldsInWhereUniqueInput, "requireSingleFieldsInWhereUniqueInput");
function beforeInputType3(args) {
  const { inputType: inputType2 } = args;
  if (!isWhereUniqueInputType(inputType2.name) || inputType2.fields.length !== 1) {
    return;
  }
  for (const field of inputType2.fields) {
    field.isRequired = true;
    field.isNullable = false;
  }
}
__name(beforeInputType3, "beforeInputType");
function isWhereUniqueInputType(name) {
  return name.endsWith("WhereUniqueInput");
}
__name(isWhereUniqueInputType, "isWhereUniqueInputType");

// src/handlers/warning.ts
function warning(message) {
  if (Array.isArray(message)) {
    console.log("prisma-nestjs-graphql:");
    console.log(message.join("\n"));
  } else {
    console.log("prisma-nestjs-graphql:", message);
  }
}
__name(warning, "warning");

// src/helpers/create-config.ts
var import_assert5 = require("assert");
var import_filenamify = __toESM(require("filenamify"));
var import_flat = require("flat");
var import_fs2 = require("fs");
var import_json55 = __toESM(require("json5"));
var import_lodash7 = require("lodash");
var import_outmatch3 = __toESM(require("outmatch"));
function createConfig(data) {
  var _a;
  const config = (0, import_lodash7.merge)({}, (0, import_flat.unflatten)(data, {
    delimiter: "_"
  }));
  const $warnings = [];
  const configOutputFilePattern = String(config.outputFilePattern || `{model}/{name}.{type}.ts`);
  let outputFilePattern = (0, import_filenamify.default)(configOutputFilePattern, {
    replacement: "/"
  }).replace(/\.\./g, "/").replace(/\/+/g, "/");
  outputFilePattern = (0, import_lodash7.trim)(outputFilePattern, "/");
  if (outputFilePattern !== configOutputFilePattern) {
    $warnings.push(`Due to invalid filepath 'outputFilePattern' changed to '${outputFilePattern}'`);
  }
  if (config.reExportAll) {
    $warnings.push(`Option 'reExportAll' is deprecated, use 'reExport' instead`);
    if (toBoolean(config.reExportAll)) {
      config.reExport = "All";
    }
  }
  const fields = Object.fromEntries(Object.entries((_a = config.fields) != null ? _a : {}).filter(({ 1: value }) => typeof value === "object").map(([name, value]) => {
    const fieldSetting = {
      arguments: [],
      output: toBoolean(value.output),
      input: toBoolean(value.input),
      model: toBoolean(value.model),
      from: value.from,
      defaultImport: toBoolean(value.defaultImport) ? true : value.defaultImport,
      namespaceImport: value.namespaceImport
    };
    return [
      name,
      fieldSetting
    ];
  }));
  const decorate = [];
  const configDecorate = Object.values(config.decorate || {});
  for (const element of configDecorate) {
    if (!element)
      continue;
    (0, import_assert5.ok)(element.from && element.name, `Missed 'from' or 'name' part in configuration for decorate`);
    decorate.push({
      isMatchField: (0, import_outmatch3.default)(element.field, {
        separator: false
      }),
      isMatchType: (0, import_outmatch3.default)(element.type, {
        separator: false
      }),
      from: element.from,
      name: element.name,
      namedImport: toBoolean(element.namedImport),
      defaultImport: toBoolean(element.defaultImport) ? true : element.defaultImport,
      namespaceImport: element.namespaceImport,
      arguments: element.arguments ? import_json55.default.parse(element.arguments) : void 0
    });
  }
  return {
    outputFilePattern,
    tsConfigFilePath: createTsConfigFilePathValue(config.tsConfigFilePath),
    combineScalarFilters: toBoolean(config.combineScalarFilters),
    noAtomicOperations: toBoolean(config.noAtomicOperations),
    reExport: ReExport[String(config.reExport)] || ReExport.None,
    emitSingle: toBoolean(config.emitSingle),
    emitCompiled: toBoolean(config.emitCompiled),
    $warnings,
    fields,
    purgeOutput: toBoolean(config.purgeOutput),
    useInputType: createUseInputType(config.useInputType),
    noTypeId: toBoolean(config.noTypeId),
    requireSingleFieldsInWhereUniqueInput: toBoolean(config.requireSingleFieldsInWhereUniqueInput),
    graphqlScalars: config.graphqlScalars || {},
    decorate
  };
}
__name(createConfig, "createConfig");
var tsConfigFileExists = (0, import_lodash7.memoize)((filePath) => {
  return (0, import_fs2.existsSync)(filePath);
});
function createTsConfigFilePathValue(value) {
  if (typeof value === "string")
    return value;
  if (tsConfigFileExists("tsconfig.json"))
    return "tsconfig.json";
}
__name(createTsConfigFilePathValue, "createTsConfigFilePathValue");
function createUseInputType(data) {
  if (!data) {
    return [];
  }
  const result = [];
  for (const [typeName, useInputs] of Object.entries(data)) {
    const entry = {
      typeName,
      ALL: void 0
    };
    if (useInputs.ALL) {
      entry.ALL = useInputs.ALL;
      delete useInputs.ALL;
    }
    for (const [propertyName, pattern] of Object.entries(useInputs)) {
      entry[propertyName] = pattern;
    }
    result.push(entry);
  }
  return result;
}
__name(createUseInputType, "createUseInputType");
function toBoolean(value) {
  return [
    "true",
    "1",
    "on"
  ].includes(String(value));
}
__name(toBoolean, "toBoolean");

// src/helpers/generate-file-name.ts
var import_lodash8 = require("lodash");
var import_pluralize = __toESM(require("pluralize"));
var import_pupa3 = __toESM(require("pupa"));
function generateFileName(args) {
  const { template, type, name, getModelName: getModelName2 } = args;
  return (0, import_pupa3.default)(template, {
    type,
    get model() {
      const result = getModelName2(name) || "prisma";
      return (0, import_lodash8.kebabCase)(result);
    },
    get name() {
      let result = (0, import_lodash8.kebabCase)(name);
      for (const suffix of [
        "input",
        "args",
        "enum"
      ]) {
        const ending = `-${suffix}`;
        if (type === suffix && result.endsWith(ending)) {
          result = result.slice(0, -ending.length);
        }
      }
      return result;
    },
    plural: {
      get type() {
        return (0, import_pluralize.default)(type);
      }
    }
  });
}
__name(generateFileName, "generateFileName");

// src/helpers/factory-get-source-file.ts
function factoryGetSourceFile(args1) {
  const { outputFilePattern, output, getModelName: getModelName2, project } = args1;
  return /* @__PURE__ */ __name(function getSourceFile(args) {
    const { name, type } = args;
    let filePath = generateFileName({
      getModelName: getModelName2,
      name,
      type,
      template: outputFilePattern
    });
    filePath = `${output}/${filePath}`;
    return project.getSourceFile(filePath) || project.createSourceFile(filePath, void 0, {
      overwrite: true
    });
  }, "getSourceFile");
}
__name(factoryGetSourceFile, "factoryGetSourceFile");

// src/helpers/get-model-name.ts
var import_lodash9 = require("lodash");
function createGetModelName(modelNames) {
  return (0, import_lodash9.memoize)(tryGetName);
  function tryGetName(name) {
    return getModelName({
      modelNames,
      name
    });
  }
  __name(tryGetName, "tryGetName");
}
__name(createGetModelName, "createGetModelName");
function getModelName(args) {
  const { name, modelNames } = args;
  for (const keyword of splitKeywords) {
    const [test] = name.split(keyword, 1);
    if (modelNames.includes(test)) {
      return test;
    }
  }
  for (const keyword1 of endsWithKeywords) {
    const [test] = name.split(keyword1).slice(-1);
    if (modelNames.includes(test)) {
      return test;
    }
  }
  for (const [start, end2] of middleKeywords) {
    let test = name.slice(start.length).slice(0, -end2.length);
    if (modelNames.includes(test)) {
      return test;
    }
    test = name.slice(0, -(start + end2).length);
    if (modelNames.includes(test)) {
      return test;
    }
  }
  if (name.slice(-19) === "CompoundUniqueInput") {
    const test = name.slice(0, -19);
    const models = modelNames.filter((x) => test.startsWith(x)).sort((a, b) => b.length - a.length);
    return (0, import_lodash9.first)(models);
  }
  if (name.slice(-5) === "Count") {
    const test = name.slice(0, -5);
    if (modelNames.includes(test)) {
      return test;
    }
  }
  return void 0;
}
__name(getModelName, "getModelName");
var splitKeywords = [
  "CreateInput",
  "CreateMany",
  "CreateNested",
  "CreateOneWithout",
  "CreateOrConnect",
  "CreateWithout",
  "DistinctField",
  "Filter",
  "ManyWithout",
  "OrderByInput",
  "RelationFilter",
  "ListRelationFilter",
  "ScalarWhereInput",
  "UpdateInput",
  "UpdateMany",
  "UpdateOneRequiredWithout",
  "UpdateOneWithout",
  "UpdateWith",
  "UpsertWith",
  "UpsertWithout",
  "WhereInput",
  "WhereUniqueInput",
  "AvgAggregate",
  "SumAggregate",
  "MinAggregate",
  "MaxAggregate",
  "CountAggregate",
  "ScalarField",
  "GroupBy",
  "OrderBy",
  "UncheckedUpdate",
  "UncheckedCreate",
  "ScalarWhere",
  "CountOutputType",
  "CountOrderBy",
  "SumOrderBy",
  "MinOrderBy",
  "MaxOrderBy",
  "AvgOrderBy"
].sort((a, b) => b.length - a.length);
var endsWithKeywords = [
  "Aggregate",
  "GroupBy",
  "CreateOne",
  "DeleteMany",
  "DeleteOne",
  "FindMany",
  "FindOne",
  "FindUnique",
  "UpdateMany",
  "UpdateOne",
  "UpsertOne"
];
var middleKeywords = [
  [
    "Aggregate",
    "Args"
  ],
  [
    "CreateOne",
    "Args"
  ],
  [
    "DeleteMany",
    "Args"
  ],
  [
    "DeleteOne",
    "Args"
  ],
  [
    "FindMany",
    "Args"
  ],
  [
    "FindFirst",
    "Args"
  ],
  [
    "FindOne",
    "Args"
  ],
  [
    "FindUnique",
    "Args"
  ],
  [
    "UpdateMany",
    "Args"
  ],
  [
    "UpdateOne",
    "Args"
  ],
  [
    "UpsertOne",
    "Args"
  ],
  [
    "GroupBy",
    "Args"
  ],
  [
    "OrderBy",
    "Args"
  ]
];

// src/generate.ts
async function generate(args) {
  var _a;
  const { connectCallback, generator, skipAddOutputSourceFiles, dmmf } = args;
  const generatorOutputValue = (_a = generator.output) == null ? void 0 : _a.value;
  (0, import_assert6.ok)(generatorOutputValue, "Missing generator configuration: output");
  const eventEmitter = new import_await_event_emitter.default();
  eventEmitter.on("Warning", warning);
  eventEmitter.on("Model", modelData);
  eventEmitter.on("EnumType", registerEnum);
  eventEmitter.on("OutputType", outputType);
  eventEmitter.on("ModelOutputType", modelOutputType);
  eventEmitter.on("AggregateOutput", createAggregateInput);
  eventEmitter.on("InputType", inputType);
  eventEmitter.on("ArgsType", argsType);
  eventEmitter.on("GenerateFiles", generateFiles);
  const config = createConfig(generator.config);
  for (const message of config.$warnings) {
    eventEmitter.emitSync("Warning", message);
  }
  const project = new import_ts_morph9.Project({
    tsConfigFilePath: config.tsConfigFilePath,
    skipAddingFilesFromTsConfig: true,
    skipLoadingLibFiles: !config.emitCompiled,
    manipulationSettings: {
      quoteKind: import_ts_morph9.QuoteKind.Single
    }
  });
  if (!skipAddOutputSourceFiles) {
    project.addSourceFilesAtPaths([
      `${generatorOutputValue}/**/*.ts`,
      `!${generatorOutputValue}/**/*.d.ts`
    ]);
  }
  config.combineScalarFilters && combineScalarFilters(eventEmitter);
  config.noAtomicOperations && noAtomicOperations(eventEmitter);
  config.reExport !== ReExport.None && reExport(eventEmitter);
  config.emitSingle && emitSingle(eventEmitter);
  config.purgeOutput && purgeOutput(eventEmitter);
  config.requireSingleFieldsInWhereUniqueInput && requireSingleFieldsInWhereUniqueInput(eventEmitter);
  const models = /* @__PURE__ */ new Map();
  const modelNames = [];
  const modelFields = /* @__PURE__ */ new Map();
  const fieldSettings = /* @__PURE__ */ new Map();
  const getModelName2 = createGetModelName(modelNames);
  const getSourceFile = factoryGetSourceFile({
    output: generatorOutputValue,
    project,
    getModelName: getModelName2,
    outputFilePattern: config.outputFilePattern,
    eventEmitter
  });
  const { datamodel, schema: { inputObjectTypes, outputObjectTypes, enumTypes } } = JSON.parse(JSON.stringify(dmmf));
  const removeTypes = /* @__PURE__ */ new Set();
  const eventArguments = {
    models,
    config,
    modelNames,
    modelFields,
    fieldSettings,
    project,
    output: generatorOutputValue,
    getSourceFile,
    eventEmitter,
    typeNames: /* @__PURE__ */ new Set(),
    enums: (0, import_lodash10.mapKeys)(datamodel.enums, (x) => x.name),
    getModelName: getModelName2,
    removeTypes
  };
  if (connectCallback) {
    await connectCallback(eventEmitter, eventArguments);
  }
  await eventEmitter.emit("Begin", eventArguments);
  for (const model of datamodel.models) {
    await eventEmitter.emit("Model", model, eventArguments);
  }
  for (const model1 of datamodel.types) {
    await eventEmitter.emit("Model", model1, eventArguments);
  }
  await eventEmitter.emit("PostBegin", eventArguments);
  for (const enumType of enumTypes.prisma.concat(enumTypes.model || [])) {
    await eventEmitter.emit("EnumType", enumType, eventArguments);
  }
  for (const outputType3 of outputObjectTypes.model) {
    await eventEmitter.emit("ModelOutputType", outputType3, eventArguments);
  }
  const queryOutputTypes = [];
  for (const outputType1 of outputObjectTypes.prisma) {
    if ([
      "Query",
      "Mutation"
    ].includes(outputType1.name)) {
      queryOutputTypes.push(outputType1);
      continue;
    }
    await eventEmitter.emit("OutputType", outputType1, eventArguments);
  }
  const inputTypes = inputObjectTypes.prisma.concat(inputObjectTypes.model || []);
  for (const inputType1 of inputTypes) {
    const event = {
      ...eventArguments,
      inputType: inputType1,
      fileType: "input",
      classDecoratorName: "InputType"
    };
    if (inputType1.fields.length === 0) {
      removeTypes.add(inputType1.name);
      continue;
    }
    await eventEmitter.emit("BeforeInputType", event);
    await eventEmitter.emit("InputType", event);
  }
  for (const outputType2 of queryOutputTypes) {
    for (const field of outputType2.fields) {
      await eventEmitter.emit("ArgsType", field, eventArguments);
    }
  }
  await eventEmitter.emit("BeforeGenerateFiles", eventArguments);
  await eventEmitter.emit("GenerateFiles", eventArguments);
  await eventEmitter.emit("End", eventArguments);
  for (const name of Object.keys(eventEmitter._events)) {
    eventEmitter.off(name);
  }
}
__name(generate, "generate");

// src/index.ts
(0, import_generator_helper.generatorHandler)({
  async onGenerate(options) {
    await generate(options);
  },
  onManifest() {
    return {
      defaultOutput: ".",
      prettyName: "Prisma NestJS/GraphQL"
    };
  }
});
